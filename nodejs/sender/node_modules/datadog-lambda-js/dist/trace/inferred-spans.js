"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpanInferrer = void 0;
var trigger_1 = require("./trigger");
var SpanInferrer = /** @class */ (function () {
    function SpanInferrer(traceWrapper) {
        this.traceWrapper = traceWrapper;
    }
    SpanInferrer.prototype.createInferredSpan = function (event, context) {
        var eventSource = (0, trigger_1.parseEventSource)(event);
        if (eventSource === trigger_1.eventSources.lambdaUrl) {
            return this.createInferredSpanForLambdaUrl(event, context);
        }
    };
    SpanInferrer.prototype.createInferredSpanForLambdaUrl = function (event, context) {
        var options = {};
        var domain = event.requestContext.domainName;
        var path = event.rawPath;
        options.tags = {
            operation_name: "aws.lambda.url",
            "http.url": domain + path,
            endpoint: path,
            "http.method": event.requestContext.httpMethod,
            resource_name: domain + path,
            request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
        };
        options.type = "serverless";
        options.service = "aws.lambda";
        var request_time_epoch = event.requestContext.timeEpoch;
        options.startTime = request_time_epoch;
        var args = {
            resource: domain + path,
            span_type: "http",
        };
        // verify, but I think traceOptions can take a startTime.
        // https://github.com/opentracing/opentracing-javascript/blob/111ea4f7939c8f8f538333330d72115e5b28bcce/src/tracer.ts#L35
        /// span.finish(endTime) should work
        var span = this.traceWrapper.startSpan("aws.lambda.url", options);
        return span;
    };
    return SpanInferrer;
}());
exports.SpanInferrer = SpanInferrer;
//# sourceMappingURL=inferred-spans.js.map