"use strict";
/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateToDatadog = void 0;
const api_1 = require("@opentelemetry/api");
const core_1 = require("@opentelemetry/core");
const types_1 = require("./types");
const defaults_1 = require("./defaults");
const INTERNAL_TRACE_REGEX = /v\d\.\d\/traces/;
const DD_SPAN_KIND_MAPPING = {
    [api_1.SpanKind.CLIENT]: defaults_1.DatadogDefaults.CLIENT,
    [api_1.SpanKind.SERVER]: defaults_1.DatadogDefaults.SERVER,
    [api_1.SpanKind.CONSUMER]: defaults_1.DatadogDefaults.CONSUMER,
    [api_1.SpanKind.PRODUCER]: defaults_1.DatadogDefaults.PRODUCER,
    // When absent, the span is local.
    [api_1.SpanKind.INTERNAL]: defaults_1.DatadogDefaults.INTERNAL,
};
const DD_SPAN_TYPE_MAPPING = {
    [defaults_1.DatadogOtelInstrumentations.GRPC]: defaults_1.DatadogInstrumentationTypes.WEB,
    [defaults_1.DatadogOtelInstrumentations.HTTP]: defaults_1.DatadogInstrumentationTypes.HTTP,
    [defaults_1.DatadogOtelInstrumentations.HTTPS]: defaults_1.DatadogInstrumentationTypes.HTTP,
    [defaults_1.DatadogOtelInstrumentations.EXPRESS]: defaults_1.DatadogInstrumentationTypes.WEB,
    [defaults_1.DatadogOtelInstrumentations.IOREDIS]: defaults_1.DatadogInstrumentationTypes.REDIS,
    [defaults_1.DatadogOtelInstrumentations.MONGODB]: defaults_1.DatadogInstrumentationTypes.MONGODB,
    [defaults_1.DatadogOtelInstrumentations.MYSQL]: defaults_1.DatadogInstrumentationTypes.SQL,
    [defaults_1.DatadogOtelInstrumentations.PGPOOL]: defaults_1.DatadogInstrumentationTypes.SQL,
    [defaults_1.DatadogOtelInstrumentations.PG]: defaults_1.DatadogInstrumentationTypes.SQL,
    [defaults_1.DatadogOtelInstrumentations.REDIS]: defaults_1.DatadogInstrumentationTypes.REDIS,
};
// dummy tracer and default sampling logic
const NOOP_TRACER = new types_1.NoopTracer();
const SAMPLER = new types_1.Sampler(1);
/**
 * Translate OpenTelemetry ReadableSpans to Datadog Spans
 * @param spans Spans to be translated
 */
function translateToDatadog(spans, serviceName, env, version, tags) {
    return spans
        .map(span => {
        const defaultTags = createDefaultTags(tags);
        const ddSpan = createSpan(span, serviceName, defaultTags, env, version);
        return ddSpan;
    })
        .map(types_1.format);
}
exports.translateToDatadog = translateToDatadog;
function createSpan(span, serviceName, tags, env, version) {
    // convert to datadog span
    const [ddTraceId, ddSpanId, ddParentId] = getTraceContext(span);
    const [ddResourceTags, ddResourceServiceName] = getResourceInfo(span);
    // generate datadog span base
    const ddSpanBase = new types_1.Span(NOOP_TRACER, null, SAMPLER, null, {
        startTime: core_1.hrTimeToMilliseconds(span.startTime),
        tags: Object.assign(tags, ddResourceTags),
        operationName: createSpanName(span),
    });
    const ddSpanBaseContext = ddSpanBase.context();
    ddSpanBaseContext._traceId = ddTraceId;
    ddSpanBaseContext._spanId = ddSpanId;
    ddSpanBaseContext._parentId = ddParentId;
    // set error code
    addErrors(ddSpanBase, span);
    // set span kind
    addSpanKind(ddSpanBase, span);
    // set span type
    addSpanType(ddSpanBase, span);
    // set datadog specific env and version tags
    addDatadogTags(ddSpanBase, span, serviceName, env, version, ddResourceServiceName);
    // set sampling rate
    setSamplingRate(ddSpanBase, span);
    // set span duration
    setDuration(ddSpanBase, span);
    // mark as finished span so that it is exported
    ddSpanBaseContext._isFinished = true;
    return ddSpanBase;
}
function addErrors(ddSpanBase, span) {
    // TODO: set error.msg error.type error.stack based on error events
    // Determine if OpenTelemetry-JS has implemented https://github.com/open-telemetry/opentelemetry-specification/pull/697
    // and if the type and stacktrace are officially recorded. Until this is done,
    // we can infer a type by using the status code and also the non spec `<library>.error_name` attribute
    if (span.status.code === api_1.StatusCode.ERROR) {
        ddSpanBase.setTag(defaults_1.DatadogDefaults.ERROR_TAG, defaults_1.DatadogDefaults.ERROR);
        ddSpanBase.setTag(defaults_1.DatadogDefaults.ERROR_MSG_TAG, span.status.message);
        ddSpanBase.setTag(defaults_1.DatadogDefaults.ERROR_TYPE_TAG, defaults_1.DatadogDefaults.ERROR_TYPE_DEFAULT_VALUE);
        for (const [key, value] of Object.entries(span.attributes)) {
            if (key.indexOf(defaults_1.DatadogDefaults.ERR_NAME_SUBSTRING) >= 0 && value) {
                ddSpanBase.setTag(defaults_1.DatadogDefaults.ERROR_TYPE_TAG, value.toString());
                break;
            }
        }
    }
}
function addSpanKind(ddSpanBase, span) {
    if (DD_SPAN_KIND_MAPPING[span.kind]) {
        ddSpanBase.setTag(defaults_1.DatadogDefaults.SPAN_KIND, DD_SPAN_KIND_MAPPING[span.kind]);
    }
}
function addSpanType(ddSpanBase, span) {
    // span.instrumentationLibrary.name is not in v0.9.0 but has been merged
    if (getInstrumentationName(span)) {
        if (DD_SPAN_TYPE_MAPPING[getInstrumentationName(span) || '']) {
            ddSpanBase.setTag(defaults_1.DatadogDefaults.SPAN_TYPE, DD_SPAN_TYPE_MAPPING[getInstrumentationName(span) || '']);
        }
    }
}
function addDatadogTags(ddSpanBase, span, serviceName, env, version, ddResourceServiceName) {
    // set reserved service and resource tags
    ddSpanBase.addTags({
        [defaults_1.DatadogDefaults.RESOURCE_TAG]: createResource(span),
        [defaults_1.DatadogDefaults.SERVICE_TAG]: ddResourceServiceName || serviceName,
    });
    // set env tag
    if (env) {
        ddSpanBase.setTag(defaults_1.DatadogDefaults.ENV_KEY, env);
    }
    // set origin and version on root span only
    if (span.parentSpanId === undefined) {
        const origin = createOriginString(span);
        if (origin) {
            ddSpanBase.setTag(defaults_1.DatadogDefaults.DD_ORIGIN, origin);
        }
        if (version) {
            ddSpanBase.setTag(defaults_1.DatadogDefaults.VERSION_KEY, version);
        }
    }
    // set span attibutes as tags - takes precedence over env vars
    // span tags should be strings
    for (const [key, value] of Object.entries(span.attributes)) {
        if (value !== undefined) {
            ddSpanBase.setTag(key, value);
        }
    }
}
function getTraceContext(span) {
    return [
        types_1.id(span.spanContext.traceId),
        types_1.id(span.spanContext.spanId),
        span.parentSpanId ? types_1.id(span.parentSpanId) : null,
    ];
}
function createDefaultTags(tags) {
    // Parse a string of tags typically provided via environment variables.
    // The expected string is of the form: "key1:value1,key2:value2"
    const tagMap = {};
    const tagArray = (tags === null || tags === void 0 ? void 0 : tags.split(',')) || [];
    for (let i = 0, j = tagArray.length; i < j; i++) {
        const kvTuple = tagArray[i].split(':');
        // ensure default tag env var or  arg is not malformed
        if (kvTuple.length !== 2 ||
            !kvTuple[0] ||
            !kvTuple[1] ||
            kvTuple[1].endsWith(':'))
            return {};
        tagMap[kvTuple[0]] = kvTuple[1];
    }
    return tagMap;
}
function createOriginString(span) {
    // for some reason traceState keys must be w3c compliant and not stat with underscore
    // using dd_origin for internal tracestate and setting datadog tag as _dd_origin
    return (span.spanContext.traceState &&
        span.spanContext.traceState.get(defaults_1.DatadogDefaults.OT_ALLOWED_DD_ORIGIN));
}
function createSpanName(span) {
    // span.instrumentationLibrary.name is not in v0.9.0 but has been merged
    const instrumentationName = getInstrumentationName(span);
    const spanKind = DD_SPAN_KIND_MAPPING[span.kind];
    if (instrumentationName) {
        const sanitizedName = instrumentationName
            .replace('@', '')
            .replace('/', '_');
        return `${sanitizedName}.${spanKind}`;
    }
    return spanKind || span.name;
}
function createResource(span) {
    if (span.attributes[defaults_1.DatadogDefaults.HTTP_METHOD]) {
        const route = span.attributes['http.route'] ||
            span.attributes[defaults_1.DatadogDefaults.HTTP_TARGET];
        if (route) {
            return `${span.attributes[defaults_1.DatadogDefaults.HTTP_METHOD]} ${route}`;
        }
        return `${span.attributes[defaults_1.DatadogDefaults.HTTP_METHOD]}`;
    }
    return span.name;
}
function getInstrumentationName(span) {
    return span.instrumentationLibrary && span.instrumentationLibrary.name;
}
function getSamplingRate(span) {
    if ((api_1.TraceFlags.SAMPLED & span.spanContext.traceFlags) ===
        api_1.TraceFlags.SAMPLED) {
        return defaults_1.DatadogSamplingCodes.AUTO_KEEP;
    }
    else {
        return defaults_1.DatadogSamplingCodes.AUTO_REJECT;
    }
}
function isInternalRequest(span) {
    if (typeof span.attributes['http.target'] === 'string') {
        return span.attributes['http.target'].match(INTERNAL_TRACE_REGEX)
            ? true
            : false;
    }
}
function setDuration(ddSpanBase, span) {
    // set span duration
    const duration = core_1.hrTimeToMilliseconds(span.endTime) - core_1.hrTimeToMilliseconds(span.startTime);
    ddSpanBase._duration = duration;
}
function setSamplingRate(ddSpanBase, span) {
    // filter for internal requests to trace-agent and set sampling rate
    const samplingRate = getSamplingRate(span);
    const internalRequest = isInternalRequest(span);
    if (internalRequest) {
        // TODO: add more robust way to drop internal requests
        ddSpanBase.context()._traceFlags.sampled = false;
        ddSpanBase.context()._sampling.priority = defaults_1.DatadogSamplingCodes.USER_REJECT;
        ddSpanBase.setTag(defaults_1.DatadogDefaults.SAMPLE_RATE_METRIC_KEY, defaults_1.DatadogSamplingCodes.USER_REJECT);
    }
    else if (samplingRate !== undefined) {
        ddSpanBase.setTag(defaults_1.DatadogDefaults.SAMPLE_RATE_METRIC_KEY, samplingRate);
    }
}
function getResourceInfo(span) {
    // extract the resource labels/attributes and potential service name to use for spans
    const ddResourceTags = {};
    let resourceServiceName;
    const resource = span.resource;
    if (!resource)
        return [ddResourceTags, resourceServiceName];
    const resourceTags = resource['labels'] || resource['attributes'];
    if (!resourceTags)
        return [ddResourceTags, resourceServiceName];
    // the spec around whether this is labels or attributes varies between versions
    for (const [key, value] of Object.entries(resourceTags)) {
        if (key === 'service.name') {
            resourceServiceName = value.toString();
        }
        else {
            ddResourceTags[key] = value.toString();
        }
    }
    return [ddResourceTags, resourceServiceName];
}
//# sourceMappingURL=transform.js.map