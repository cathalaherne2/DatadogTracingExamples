"use strict";
/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DatadogPropagator = void 0;
const api_1 = require("@opentelemetry/api");
const core_1 = require("@opentelemetry/core");
const types_1 = require("./types");
const defaults_1 = require("./defaults");
const VALID_TRACEID_REGEX = /^([0-9a-f]{16}){1,2}$/i;
const VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
const INVALID_ID_REGEX = /^0+$/i;
function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && !INVALID_ID_REGEX.test(traceId);
}
function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && !INVALID_ID_REGEX.test(spanId);
}
/**
 * Propagator for the Datadog HTTP header format.
 * Based on: https://github.com/DataDog/dd-trace-js/blob/master/packages/dd-trace/src/opentracing/propagation/text_map.js
 */
class DatadogPropagator {
    inject(context, carrier, setter) {
        const spanContext = api_1.getSpanContext(context);
        if (!spanContext || !api_1.isSpanContextValid(spanContext))
            return;
        if (isValidTraceId(spanContext.traceId) &&
            isValidSpanId(spanContext.spanId)) {
            const ddTraceId = types_1.id(spanContext.traceId).toString(10);
            const ddSpanId = types_1.id(spanContext.spanId).toString(10);
            setter.set(carrier, defaults_1.DatadogPropagationDefaults.X_DD_TRACE_ID, ddTraceId);
            setter.set(carrier, defaults_1.DatadogPropagationDefaults.X_DD_PARENT_ID, ddSpanId);
            // Current Otel-DD exporter behavior in other languages is to set to zero if falsey
            setter.set(carrier, defaults_1.DatadogPropagationDefaults.X_DD_SAMPLING_PRIORITY, (api_1.TraceFlags.SAMPLED & spanContext.traceFlags) === api_1.TraceFlags.SAMPLED
                ? '1'
                : '0');
            // Current Otel-DD exporter behavior in other languages is to only set origin tag
            // if it exists, otherwise don't set header
            if (spanContext.traceState !== undefined &&
                spanContext.traceState.get(defaults_1.DatadogDefaults.OT_ALLOWED_DD_ORIGIN)) {
                const originString = spanContext.traceState.get(defaults_1.DatadogDefaults.OT_ALLOWED_DD_ORIGIN) ||
                    '';
                setter.set(carrier, defaults_1.DatadogPropagationDefaults.X_DD_ORIGIN, originString);
            }
        }
    }
    extract(context, carrier, getter) {
        const traceIdHeader = getter.get(carrier, defaults_1.DatadogPropagationDefaults.X_DD_TRACE_ID);
        const spanIdHeader = getter.get(carrier, defaults_1.DatadogPropagationDefaults.X_DD_PARENT_ID);
        const sampledHeader = getter.get(carrier, defaults_1.DatadogPropagationDefaults.X_DD_SAMPLING_PRIORITY);
        const originHeader = getter.get(carrier, defaults_1.DatadogPropagationDefaults.X_DD_ORIGIN);
        // I suppose header formats can format these as arrays
        // keeping this from b3propagator
        const traceIdHeaderValue = Array.isArray(traceIdHeader)
            ? traceIdHeader[0]
            : traceIdHeader;
        const spanIdHeaderValue = Array.isArray(spanIdHeader)
            ? spanIdHeader[0]
            : spanIdHeader;
        const sampled = Array.isArray(sampledHeader)
            ? sampledHeader[0]
            : sampledHeader;
        const origin = Array.isArray(originHeader) ? originHeader[0] : originHeader;
        // check if we've extracted a trace and span
        if (!traceIdHeaderValue || !spanIdHeaderValue) {
            return context;
        }
        // TODO: is this accurate?
        const traceId = types_1.id(traceIdHeaderValue, 10).toString('hex');
        const spanId = types_1.id(spanIdHeaderValue, 10).toString('hex');
        if (isValidTraceId(traceId) && isValidSpanId(spanId)) {
            const contextOptions = {
                traceId: traceId,
                spanId: spanId,
                isRemote: true,
                traceFlags: isNaN(Number(sampled)) ? api_1.TraceFlags.NONE : Number(sampled),
            };
            if (origin) {
                contextOptions[defaults_1.DatadogDefaults.TRACE_STATE] = new core_1.TraceState(`${defaults_1.DatadogDefaults.OT_ALLOWED_DD_ORIGIN}=${origin}`);
            }
            return api_1.setSpanContext(context, contextOptions);
        }
        return context;
    }
    fields() {
        return [];
    }
}
exports.DatadogPropagator = DatadogPropagator;
//# sourceMappingURL=datadogPropagator.js.map